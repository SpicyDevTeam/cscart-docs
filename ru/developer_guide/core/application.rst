*****************
Класс Application
*****************

Cущность ``Tygh\Application`` появилась в версии 4.3.2.

Объект класса ``Application`` создаётся при инициализации ядра в файле **init.php**, после чего он доступен отовсюду::

  // получение объекта Application
  Tygh::$app

На текущий момент единственное его предназначение ― IoC-контейнер, хранящий объекты и фабричные анонимные функции для создания объектов.

=============
IoC-контейнер
=============

Раньше хранением объектов занимался класс ``Registry``. Сейчас его функция ― хранение кэша и других runtime-данных::

  // было
  $smarty = Registry::get('view');

  // стало
  $smarty = Tygh::$app['view'];

Контейнер, который предоставляет ``Application``, отличается от контейнера ``Registry`` возможностью "ленивого" объявления объектов, которые должны в нём храниться. Объекты, хранящиеся в контейнере, называются сервисами. Обычно это компоненты большей системы, имеющие свою узкую зону ответственности, например: менеджер отправки писем, соединение с базой данных.

::

  // Регистрируем объект в контейнере при помощи анонимной фабричной функции.
  Tygh::$app['foo'] = function($app) {
      return new Tygh\Foo();
  };

  Tygh::$app['bar'] = function($app) {
      return new Tygh\Bar($app['foo']);
  };

  // На текущий момент ни одного объекта ещё создано не было, они будут созданы по первому требованию.

  // Application вернёт результат выполнения анонимной функции-фабрики, которую мы зарегистрировали ранее.
  // Причём в конструктор класса Tygh\Bar будет передан результат выполнения другой функции-фабрики.
  $bar_instance = Tygh::$app['bar'];

  // Строка выше эквивалентна этому коду:
  $foo_instance = new Tygh\Foo();
  $bar_instance = new Tygh\Bar($foo_instance);

  // При повторном получении сервиса из контейнера будет возвращён тот же самый объект (новый не создаётся).
  var_dump($bar_instance === Tygh::$app['bar']); // true

  // Если НУЖНО чтобы при каждом обращении к сервису в контейнер возвращался НОВЫЙ объект,
  // то при регистрации сервиса необходимо обернуть анонимную функцию-фабрику таким образом:
  Tygh::$app['cool_service'] = Tygh::$app->factory(function($app) {
      return new Tygh\CoolService();
  });

  // Это всё разные объекты:
  $a = Tygh::$app['cool_service'];
  $b = Tygh::$app['cool_service'];
  $c = Tygh::$app['cool_service'];

  // Кроме вышеупомянутых способов, можно просто положить конкретный объект в контейнер ―
  // это то поведение, которое предоставлял Registry.
  Tygh::$app['my_object'] = new Tygh\MyClass();

Читайте подробную документацию по использованию контейнера на странице https://github.com/silexphp/Pimple.

Для обеспечения обратной совместимости ``Registry`` перенаправляет вызовы к сервисам ``api``, ``crypt``, ``view``, ``ajax`` и ``class_loader`` в контейнер.

===========
Что дальше?
===========

В будущем Application будет реализовывать функции-инициализаторы (``fn_init()``) и обрабатывать текущие запросы (``fn_dispatch()``).
